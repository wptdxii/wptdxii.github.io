---
title: 设计模式总结
date: 2016-08-13 21:01:21
categories: 设计模式
tags: 设计模式
---
这篇博客介绍和记录一些常用设计模式
<!-- more -->
## 设计模式基础
设计模式是指在软件开发中，经过验证的，用于解决在特定环境下的、重复出现的、特定问题的解决方案。
### 设计模式的分类

- 创建型模式：抽象了对象实例化的过程，用来帮助创建对象的实例
- 结构型模式：描述如何组合类和对象以获得更大的结构
- 行为型模式：描述算法和对象间职责的分配

## 简单工厂
### 场景
#### 接口和抽象类选择
- 优先选用接口
- 既要定义子类功能，由于为子类提供公共功能时应该选择抽象类

#### 问题
Java程序设计里边，非常讲究层的划分和模块的划分。通常分为表现层，逻辑层和数据层，层与层之间通过接口通信，每一层又由许多组件构成，组件之间要屏蔽实现细节。
当不使用设计模式时，有如下代码实现：
定义接口
```java
public interface Api {
    public void test(String s);
}
```
定义实现
```java
//实现A
public ImplA implements Api {
    public void test(String s) {
        System.out.println("ImplA:s = " + s);
    }
}
//实现B
public ImplB implements Api {
    public void test(String s) {
        System.out.println("ImplB:s = " + s)
    }
}
```
客户端创建对象
```java
public class Client {
    public static void mian(String[] args) {
       // 客户端知道了具体实现类ImplA
        Api api = new ImplA();
        api.test("this is Client");
    }
}
```
**问题：**客户端与接口处于不同的模块，应该通过接口进行通信，并屏蔽模块内部的实现细节，但上边的创建方式中，Client 不仅知道了接口Api，并且知道了其具体实现类ImplA。那么在只知道接口而不知道具体实现时，应该使用简单工厂来创建对象。
### 解决方案
可以使用简单工厂模式来解决这种问题。定义的接口和具体实现类不变，创建工程类，用于向其它模块提供对象的创建。
创建工厂类
```java
//工厂类与接口实现类在同一个模块下，可以知道实现类
public class Factory {
    public static Api getApi(int type) {
        Api api = null;
        switch(type) {
            case 1:
                api = new ImplA();
                break;
            case 2:
                api = new ImplB();
                break;
        }

        return api;
    }
}
```
改写客户端：
```java
public class Client {
    private Client() {
    }
    public static void main(String[] args) {
        Api api = Factory.getApi(1);
        api.test("this is client");
    }
}
```
上面工厂类的写法，当需要添加新的接口实现类时，是需要修改工厂类的，并且客户端需要通过传入参数来选择创建的实现类实例，这就要求在一定程度上，向Client暴露了内部的实现细节。可以通过可配置的简单工厂来解决这个问题。
可配置的简单工厂：
```java
//1. 在Factory同一包下创建配置文件factory.properties，内容如下：
ImplClass=< packagename >. < classname >
//改写工厂类
public class Factory {
     private Client() {
        }
    //不需要传参
    public static Api getApi() {
        Properties p = new Properties();
        InputStream in = null;
        try{
            in = Factory.class.getResourceAsStream("factory.Properties");
            p.load(in);
        } catch(IOException e) {
            e.printStackTrace();
        } finally {
            try {
                in.close();
            } catch(IOException e) {
                e.printStackTrace();
            }
        }

        Api api = null;
        try {
            api = (Api) Class.forName(p.getProperty("ImplClass")).newInstance();
        } catch {Exception e} {
            e.printStackTrace();
        }

        return api;

    }
}
```
改写客户端
```java
public class Client {
     private Client() {
        }
    public static void mian(String[] args) {
        // 不需要传参，更改配置文件即可
        Api api = Factory.getApi();
        api.test("this is client");
    }
}
```
### 模式讲解
- 简单工厂是创建型模式，本质是选择实现，可以用来创建接口实例、抽象类实例和普通类实例
- 简单工厂通常实现为一个工具类，私有化构造器，并将工厂方法定义为静态方法，所有也叫静态工厂
- 简单工厂可以用来创建任何对象，但通常为了职责分明，要控制在组件级别，即一个简单工厂类只负责一个组件内部的对象创建
- 简单工厂命名建议
    - 类名建议为："模块名称 + Factory"
    - 方法名建议为: "get/create + 接口名称"
- 简单工厂的优点
    - 封装：实现面向接口编程
    - 解耦：实现模块间的解耦
- 简单工厂的缺点
    - 增加客户端的复杂度
      如果通过客户端的参数来选择具体的实现类，那么客户端需要理解参数代表的具体功能和含义，增加了客户端的使用难道，并一定程度暴露了内部实现，这时可以使用可配置的简单工厂来实现
    - 不方便扩展子工厂
- 简单工厂的使用场景
    - 对外完全封装隔离具体实现
    - 对外创建对象的职责集中管理和控制
- 相关模式
    - 简单工厂和抽象工厂
        - 简单工厂可以有多个用于选择并创建对象的方法，这些方法之间可以没有联系
        - 抽象工厂是用来选择产品簇的实现的，多个用于选择并创建对象的方法直接是有联系的，这些被创建的对象通常是构成产品簇所需要的部件对象
    - 简单工厂和工厂方法
        - 工厂方法也是用来选择实现，与简单工厂的区别是把选择具体实现的功能延迟到子类实现，如果把工厂方法中的选择的实现放到父类直接实现，就等同于简单工厂
    - 简单工厂和创建型模式
        - 可以与任何创建型模式配合使用

## 外观模式
### 场景
有如下场景，有三个模块A,B和C，代码如下：
```java
//AModule接口
public interface AModuleApi {
    public void testA();
}
//AModule接口实现类
public class AModuleImpl implements AModuleApi {
    public static void testA() {
        System.out.println(" this is AModuleImpl");
    }
}
```
B模块和C模块与A模块的定义相同
当客户端需要调用这三个模块时，代码如下：
```java
public class Client {
    public static void main(String[] args) {
        new AModuleImpl().testA();
        new BModuleImpl().testB();
        new CModuleImpl().testC();
    }
}
```
当客户端需要调用系统的多个模块时，客户端会与多个模块耦合，这样会使客户端的调用变得麻烦，且当模块实现发生变动时，可能引起客户端的变动
### 解决方案
可以使用外观模式解决上述问题，需要在子系统定义外观类。
定义外观类：
```java
public class Facade {
    prvate Facade() {}
    public static void test() {
        AModuleImpl a = new AModuleImpl();
        a.testA();
         BModuleImpl b = new BModuleImpl();
        b.testA();
         CModuleImpl c = new CModuleImpl();
        c.testA();
    }
}
```
重写客户端：
```java
public class Client {
    public static void main(String[] args) {
       Facade.test();
       //当需要定制功能时，需单独调用某个模块，但如果A模块中还定义了其他供模块内部调用的方法，这样会将其他方法也暴露出去，可以使用定义接口的外观模式来实现
       // new AModuleImpl().testA();
    }
}
```
外观类也可实现为真正的interface，这会增加系统的复杂度，但这样做的好处是可以有选择性的暴露接口，尽量减少子系统对外提供的接口。
例如有子系统有A、B和C三个模块。A模块接口如下：
```java
public interface AModuleApi {
    public void testA();
    public void a1();
    pbulic void a2();
}
```
实现接口
```java
public AModule implements AModuleApi {
    // test()方法需要暴露给子系统外部
    public void testA() {
        // TODO
    }
    
    // a1()和a2()方法用在子系统内部，用来和B、C模块交互
    pubilc void a1() {
        // TODO
    }
    public void a2() {
        // TODO
    }
}
```
B模块和C模块的定义与A模块相同
定义Fasade接口
```java
public interface FacadeApi {
    //暴露接口，供外部需要定制功能时调用
    public void testA();
    public void testB();
    public void testC();
    //组合方法，提供子系统功能
    public void test();
}
```
实现外观类
```java
public class Facade implements FasadeApi {
    public void testA() {
        new AModeuleImple().testA();
    }
     public void testB() {
        new BModeuleImple().testB();
    }
     public void testC() {
        new CModeuleImple().testC();
    }
    pubilc void test() {
         new AModeuleImple().testA();
         new AModeuleImple().testC();
         new CModeuleImple().testC();
    }
}
```

改写客户端
```java
public class Client {
    public static void main(String[] args) {
        //调用子系统功能
        Facade facade = new Facade();
        fasade.test();
        //当需要定制功能时，只单独调用某个模块，这样不会将模块的其他方法暴露给外部
        // Facade facade = new Facade();
        // facade.testA();
    }
}
```
### 模式讲解
- 外观模式(Facade)是指定义一个高层接口，为子系统的一系列接口提供一个一致的界面，这个接口使该子系统变得更易使用。外观模式提供的接口不是为了给子系统提供新功能，而是为了减少外部与子系统多个模块的交互，使外部更加简单的使用子系统
- 外观模式的本质是封装交互，简化调用，可以实现功能的复用，并简化调用
- 外观类对象知道子系统各个模块，而各个模块不知道外观类对象
- 当定义了外观类时，可以绕过外观类不使用，直接调用子系统的某个模块，能实现兼顾组合功能和细节功能，因此可用来提供缺省的默认实现，当需要定制更多功能时，可以越过外观去访问子系统内部模块
- 外观类通常可以将其实现为单例，或者私有化构造器，并提供静态方法，也可以实现为真正的interface
- 外观模式的优点
    - 松散耦合：松散了子系统和客户端之间的耦合，使子系统模块更容易扩展和维护
    - 简单易用：客户端可以很方便的调用子系统的功能
    - 更好地划分访问的层次：使用interface类型的外观模式时，可以更好的划分访问层次，可以选择性的暴露模块的方法
- 外观模式的缺点
    - 不合理的外观模式容易  产生迷惑，到底是调用外观类还是直接调用模块
- 外观模式的使用场景
    - 当需要为复杂的子系统对外提供简单的接口，方便调用时
    - 当需要客户端和抽象类的实现部分松散耦合时
    - 当需要构建多层结构的系统时，可以使用外观对象作为每层的入口，简化层间的调用，也可以松散层间的耦合
- 相关模式
    - 外观模式和中介者模式
        - 中介者模式主要用来封装多个对象之间的调用，多用于系统内部的多个模式之间。需要实现具体的交互功能。主要用来松散子系统各个模块之间的耦合
        - 外观模式封装的是单向的交互，是客户端调用系统功能，而系统并不调用客户端的功能。一般是组合调用或者转调内部实现的功能，外观类并不实现这些功能。主要用来简化客户端的调用  
    - 外观模式和单例模式
        - 外观模式和单例模式可以组合使用，将外观类实现为单例的，也可以将外观类构造器私有化，  并将暴露给客户端的方法实现为静态的
    - 外观模式和抽象工厂模式
        - 外观模式主要是为了封装各个模块之间的交互，每个模块一般都有自己的接口，所有在外观类的具体实现中，可以使用抽象工厂来获得这些接口    

## 适配器模式
### 场景
例如有如下需求，在第一版时，定义接口
```java
public interface Adaptee {
    public void specificRequest();
}

```
实现接口
```java
public class AdapteeImpl implements Adaptee {
    public void specificRequest(){
        //TODO
    }
}
```
在客户端调用接口
```java
//这里假设Adaptee对客户端是可见的，即在同一模块
public class Client {
    public static void main(String[] args) {
        Adaptee adaptee = new AdapteeImpl();
        adaptee.specificRequest();
    }
}
```
这是需要改版，新增接口
```java
public interface Target{
    public void request();
}
```
实现接口
```java
public class TargetImpl implements Target{
    public void request() {
        // TODO
    }
}
```
在客户端调用新接口
```java
public class Client {
    public static void main(String[] args) {
        Target target = new TargetImpl();
        target.request();
    }
}
```
如果改版前的接口和改版后的接口需要同时使用，新客户端需要调用新的接口，但是使用之前接口的功能，即新客户端需要兼容老之前的接口，这时可以使用适配器模式来解决。
### 解决方案
定义适配器
```java
public class Adapter implements Target{
    private Adaptee adaptee;
    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    public void request() {
        adaptee.specificRequest();
    }
}
```
改写客户端
```java
public class Client {
    public static void main(String[] args) {
        Adaptee adaptee = new AdapteeImpl();
        Adapter adapter = new Adapter(adaptee);
        Target target = (Target)adapter;
        target.request();
    }
}
```
这样就实现了在客户端中调用新接口，但具体功能实现还是调用之前的接口。实现了新版客户端对之前接口的兼容。
当新版接口不稳定时需要以之前的接口为主时，这是可以使用双向适配，
定义双向适配器
```java
public class Adapter implements Target,Adaptee {
    private Target target;
    private Adaptee adaptee;
    public Adapter(Target target,Adaptee adaptee) {
        this.target = target;
        this.adaptee = adaptee;
    }

    public void request() {
        adaptee.specificRequest();
    }
    public void specificRequest() {
        target.request();
    }
}
```
改写客户端
```java
public class Client {
    public static void main(String[] args) {
        Target target = new TargetImpl();
        Adaptee adaptee = new AdapteeImpl();
        Adapter adapter = new Adapter(target, adaptee);
        Adaptee old = (Adaptee) adapter;
        //调用之前接口
        old.specificRequest();
    }
}
```
上边适配器是对象适配器，也可以使用类适配器实现
```java
//继承被适配对象而不是接口
public class Adapter extends AdapteeImpl implements Target{
    public void request() {
        this.specificRequest();
    }
}
```
### 模式讲解
- 适配器模式只指将一个类的接口转换为另一个类的接口。适配器模式使得那些原理因为接口不兼容而不能一起工作的类可以一起工作。适配器模式的本质是转换匹配，复用功能。
- 适配器模式是结构型模式
- 适配器模式的主要功能是转换匹配，目的是复用已有功能，而不是实现新接口。适配器中也可以实现新功能，可以是独立的新功能也可以是被适配对象方法的组合调用，这种适配器叫做智能适配器。
- 适配器是一个类，通常实现目标接口，并将被适配对象通过构造器传入，当然也可以传入多个被适配对象进行适配。
- 当之前的接口需要兼容新接口时，可以使用双向适配器进行适配
- 适配器根据实现方式不同分为对象适配器和类适配器，对象适配器依赖对象组合，即将被适配器对象传入适配器中。类适配器采用多继承对一个接口和另一个接口进行适配，由于Java不支持多继承，所以在Java中实现的类适配器并不标准。类适配器并不需要传入被适配的对象，而是通过继承被适配的类或者接口而获得该对象，并实现目标接口
- 开发中尽量使用对象适配器来实现，但也要根据具体情况分析
- 当需要适配多个子类时，可以直接适配父类，即对象适配器中使用泛型将父类作为参数
- 适配器模式的优点
    - 更好的复用性
    - 更好的可扩展性
- 适配器模式的缺点
    - 会使系统变得凌乱复杂
- 适配器模式的使用场景
    - 一个类已经存在，但接口不匹配
    - 需要创建一个可复用的类，但这个类可能和一些不兼容的类一起工作
- 相关模式
    - 适配器模式和桥接模式
        - 适配器模式是为了将不兼容的接口转换匹配
        - 桥接模式是为了让接口和实现部分分离，以便能够相对独立地变化
    - 适配器模式和装饰模式
        - 适配器模式适配后需要改变接口，适配器模式可以简单地模式装饰模式，在调用被适配对象的方法前后执行一些操作
        - 装饰模式不改变接口，比较容易实现递归组合
    - 适配器模式和代理模式
        - 两种模式可以结合使用，在调用被适配对象时可以使用代理，增加灵活性
    - 适配器模式和抽象工厂模式
        - 适配模式通常需要适配的是一个对象，当被适配的是接口时，可以用抽象工厂模式创建对象
        
## 单例模式
### 场景
在系统运行期间，某个类只需要创建一个实例，例如读取配置文件的类，那么可以采用单例模式
### 解决方案
**饿汉式实现**
```java
public class Singleton {
    private static Singleton instance = new Singleton();
    //私有化构造器
    private Singleton(){}
    public static Singleton getInstance() {
        return instance;
    }
}
```
**饿汉式实现**
```java
public class Singleton {
    // 被volatile修饰的变量在本地不会被缓存，会屏蔽虚拟机的代码优化，效率可能稍低
    private volatile static Singleton instance = null;
    //私有化构造器
    private Singleton(){}

    public static Singleton getInstance() {
        if(instance == null) {
            synchronized(Singleton.class) {
                if(instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
**使用缓存实现**
```java
public class Singleton {
    private static final String DEFAULT_KEY = "ONE";
    private static Map<String, Singleton> map = new HashMap<>();
    private Singleton(){}
    public static Singleton getInstance() {
        Singleton instance =  (Singleton)map.get(DEFAULT_KEY);
        if(instance == null) {
            instance = new Singleton();
            map.put(DEFAULT_KEY, instance);
        }
        return instance;
    }
}
```
**lazy initialization holder class**
```java
//Java中最好的实现方式
public class Singleton {
    //只有第一次调用时才会装载，实现延迟加载
    private static class SingletonHolder {
        //静态初始化器，由JVM保证线程安全
        private static Singleton instance = new Singleton();
    }

    //私有化构造器
    private Singleton(){}

    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }
}
```
- 内部类分为静态内部类和非静态内部类，静态内部类在第一次调用时才会被装载
- 在如下情况下JVM会隐含地执行同步：
    - 由静态初始化器(静态字段或者static{}块中的初始化器)初始化数据时
    - 访问final字段时
    - 在创建线程之前创建对象时
    - 线程可以看见它将要处理的对象时

**使用枚举实现**
```java
//使用枚举可以自动实现序列化
public enum Singleton {
    INSTANCE;

    //TODO
    //定义自己的方法和属性
}
```
### 模式讲解
- 单例模式是指保证一个类只有一个实例，并提供一个访问它的全局访问点。单例模式是创建型模式，单例模式的本质是控制实例数目
- 单例模式可以有自己的方法和成员变量，与普通类一样
- 单例模式在Java中作用范围是虚拟机，即一个虚拟机只有一个实例
- 懒汉式是时间换空间，饿汉式是空间换时间


## 工厂方法模式
### 场景
在实现业务功能的对象中，当不知道具体实现类的情况下，又需要调用该类的方法，这时可以用工厂方法解决
### 解决方案
定义被使用对象接口
```java
//工厂方法创建的对象的接口
public interface Product {
    public void test();
}
```
实现接口
```java
public class ConcreteProductA implements Product {
    public void test() {
        // TODO
    }
}

public class ConcreteProductB implements Product {
    public void test() {
        //TODO
    }
}
```
定义抽象创建器
```java
//抽象类
public abstract class Creator {
    //工厂方法
    protected abstract Product factoryMethod();

    public void test() {
        Product product = factoryMethod();
        product.test();
    }
}
```
重写抽象创建器
```java
public class ConcreteCreatorA extends Creator {
    protected Product factoryMethod() {
        return new ConcreteProductA();
    }
}

public class ConcreteCreatorB extends Creator {
    protected Product factoryMethod() {
        return new ConcreteProductB();
    }
}
```
客户端调用
```java
public class Client {
    public static void main(String[] args) {
        //选择某个创建器
        Creator creator = new ConcreteCreatorA();
    //   Creator creator = new ConcreteCreatorB();
        creator.test();
    }
}
```
也可以将抽象创建器实现为具体类，用于提供默认实现
```java
//可以子类继承重写该方法
public class Creator {
    protected Product factoryMethod() {
        return new ConcreteProductA();
    }

    public void test() {
        Product product = factoryMethod();
        product.test();
    }
}
```
在客户端调用
```java
public class Client {
    public static void main(String[] args) {
        //提供了默认实现，也可以重写子类
        Creator creator = new Creator();
        creator.test();
    }
}
```
以上情况都是客户端使用创建器Creator对象的情况，客户端也可以使用创建器Creator创建的对象
创建客户端需要创建的对象
```java
//该对象的创建依赖其它对象
public class ProductOjb {
    private Product productA;
    private Product productB;

    public ProductOjb (Product productA, Product productB) {
        this.productA = productA;
        this.productB = productB;
    }
    public void test() {
        productA.test();
        productB.test();
    }
}
```
定义创建器
```java
public abstract class Creator {
    protected abstract Product factoryMethodA();
    protected abstract Product factoryMethodB();
    //使用创建器创建对象
    public ProductOjb createProductObj() {
        Product productA = factoryMethodA();
        Product productB = factoryMethodB();

        ProductOjb productOjb = new ProductOjb(productA, productB);

        return productOjb;
    }
}
```
继承抽象创建器实现子类
```java
public class ConcreteCreatorA extends Creator {
    protected Product factoryMethodA {
        return new ConcreteProductA();
    }
    protected Product factoryMethodB {
        return new ConcreteProductB();
    }
}

public class ConcreteCreatorB extends Creator {
    protected Product factoryMethodA {
        return new ConcreteProductB();
    }
    protected Product factoryMethodB {
        return new ConcreteProductA();
    }
}
```
在客户端调用
```java
public class Client {
    public static void main(String[] args) {
        Creator creator = new ConcreteCreatorA();
        // Creator creator = new ConcreteCreatorB();
        ProductOjb productObj = creator.createProductObj();
        //使用该对象
    }
}
```
也可以使用参数化的工厂方法
```java
//不再定义为抽象类
public class Creator {
    protected Product factoryMethod(int type) {
        Product product = null;
        if(type == 1) {
            product = new ConcreteProductA();
        } else if(type == 2) {
            product = new ConcreteProductB();
        }

        return product;
    }

    public void test(int type) {
        Product product = factoryMethod(type);
        protuct.test();
    }
}
```
在客户端中调用
```java
public class Client {
    public static void main(String[] args) {
        Creator creator = new Creator();
        creator.test(1);
    }
}
```
使用参数化工厂方法很容易扩展
```java
public class SubCreator extends Creator {
    public Product factoryMethod(int type) {
        Product product = null;
        //当需要扩展时
        if(type == 3) {
            product = new ConcreteProductC();
        } else {
            product = super.factoryMethod(type);
        }

        return product;
    }
}
```
### 模式讲解
- 工厂方法模式(Factory Method)是指定义一个用于创建对象的接口，让子类决定实例化哪个类，工厂方法使一个类的实例化延迟到子类，工厂方法模式是创建型模式，工厂方法模式的本质是延迟到子类来选择实现。工厂方法模式其实是指提供的一个方法
- 工厂方法的作用是在父类不知道具体实现的情况下，完成自身功能的调用，具体的实现延迟到子类实现
- 工厂方法模式中，工厂方法是在创建器中被调用的，即工厂方法是在其所在的类中被调用的，工厂方法虽然也可以被外部调用，但通常并不这么做，因为这并不是工厂方法的本意
- 工厂方法模式有两种使用形式，一种是客户端使用创建器Creator对象，即直接使用Creator对象的方法，另外一种是客户端使用创建器Creator创建出来的对象，即使用Creator创建出来的对象的方法
- 工厂方法模式与 IOC/DI，有相似的地方，创建器Creator子类通过工厂方法将外部资源注入
    - IOC：Inversion Of Control，控制反转
    - DI：Dependency Injection，依赖注入
    - 依赖注入和控制反转通常有三部分组成：某个对象，IOC/DI的容器，该对象需要的外部资源，IOC/DI的容器反向的将外部资源注入到该对象当中 
    - 依赖注入和控制反转是对同一件事情的不同描述，依赖注入是从对象的角度描述，控制反转是从容器的角度描述
- 工厂方法模式的优点
    - 可以在不知道具体实现的情况下编程
    - 容易扩展
    - 连接平行的类层次
- 工厂方法模式的缺点
    - Product对象和工厂方法耦合
- 工厂方法模式的使用场景
    - 当某个类需要创建某个接口的对象，又不知道具体实现
    - 当某个类本身就希望子类来创建所需对象
- 相关模式
    - 工厂方法和简单工厂
        - 从某种程度上讲，简单工厂是工厂方法的特例
    - 工厂方法和模板方法
        - 两种模式外观相似，都有一个抽象类，由子类提供实现，但是工厂方法的子类专注的是创建产品对象，模板方法的子类专注的是为固定的算法骨架提供某些步骤的实现

## 观察者模式
### 场景
当一个对象的状态发生改变，让所有依赖于它的对象得到通知，并进行相应的处理
### 解决方案
定义被观察者
```java
public class Subject {
    //维护被观察者
    private List<Observer> ovservers = new Arraylist<>();

    //注册观察者
    public void register(Observer ovserver) {
        ovservers.add(ovserver);
    }

    //解注册
    public void unregister(Observer ovserver) {
        ovservers.remove(ovserver);
    }

    //通知所有观察者
    public void notifyObservers() {
        for(Observer ovserver : ovservers) {
            ovserver.update(this);
        }
    }
}
```
继承被观察者，添加业务
```java
public class ConcreteSubject extends Subject {
    private String state;

    public String getState() {
        return state;
    }
    //调用该方法时，会通知所有观察者
    public void setState(String state) {
        //状态发生改变后才通知，注意顺序
        this.state = this.state;
        super.notifyObservers();
    }
}
```
定义观察者接口
```java
public interface Observer {
    void update(Subject subject);
}
```
实现观察者
```java
public class ConcreteObserver implements Observer {
    public void updatee(Subject subject) {
        //获取被观察者的变化数据
        String state = (ConcreteSubject)subject.getState();
        System.out.println("receive " + state);
    }
}
```
客户端调用
```java
public class Client {
    public static void main(String[] args) {
        ConcreteObserver ovserver = new ConcreteObserver();

        ConcreteSubject subject = new ConcreteSubject();
        subject.register(ovserver);

        subject.setState("state changed");

        //ConcreteOberver 的 update()方法会被调用
    }
}
```
观察者模式分为拉模型和推模型，上面的实例是拉模型
推模型时改写被观察者
```java
public class Subject {
    println List<ovserver> ovservers = new Arraylist<>();

    public void register(Observer ovservers) {
        ovservers.add(ovserver);
    }

    public void unregister(ovserver ovserver) {
        ovservers.remove(ovserver);
    }

    //推模型在定义该方法时需要传入参数有参数
    public void notifyObservers(String state) {
        for(ovserver ovserver : ovservers) {
            //调用观察者方法
            ovserver.update(state);
        }
    }
}
```
推模型与拉模型的区别是定义通知方法的时候需要定义参数
继承被观察者，添加业务
```java
public class ConcreteSubject extends Subject {
    private String state;

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
        super.notifyObservers(stae);
    }
} 
```
定义观察者接口
```java
public interface Observer {
    void update(String state);
}
```
实现观察者接口
```java
public class ConcreteObserver implements Observer {
    public void update(String state) {
        System.out.println(state);
    }
}
```
客户端调用
```java
public class Client {
    public state void main(String[] args) {
        ConcreteObserver ovserver = new ConcreteObserver();

        ConcreteSubject subject = new ConcreteSubject();
        subject.register(ovserver);

        subject.setState("state changed");
    }
}
```
以上实现就是推模型，在通知方法中需要传入参数。

Java中已经实现了观察者模式
不需要定义被观察者对象，直接实现被观察者
```java
public class ConcreteObservable extends java.util.oververable {
    private String state;
    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
        //必须调用该方法
        this.setChanged();

        //推模型
        this.notifyObservers(getState());

        //拉模型
        this.notifyObservers();
    }
}
```
实现观察者
```java
public class ConcreteObserver implements java.util.Observer {
    public void update(Observerable obs, Object obj) {

        //根据拉模式还是推模型选定参数
        //无论拉模型还是推模式都会将Observerable传递过来
        //拉模型 obj == null
        obs.getState();


        //推模型
        if(obj != null) {
            System.out.println(obj.toString());
        }

    }
}
```
客户端调用
```java
public class Client {
    public static void main(String[] args) {
        ConcreteObserver ovserver = new ConcreteObserver();

        ConcreteObservable ovserverable = new ConcreteObservable();
        ovserverable.register(ovserver);

        ovserverable.setState("state changed");
        //观察者的update()方法会被调用
    }
}
```
当需要区别对待观察者时，可以使用扩展的观察者模式
定义抽象的被观察者
```java

public abstract class Subject {
    protected List<Observer> ovservers = new Arraylist<>();

    public void register(Observer ovserver) {
        ovservers.add(ovserver);
    }

    public void unregister(Observer ovserver) {
        ovservers.remove(Observer);
    }

    public abstract void notifyObservers();
    public abstract int getLevel();
}
```
创建具体被观察者
```java
public class ConcreteSubject extends Subject {
    private int level = 0;

    public int getLevel() {
        return this.level;
    }

    public void setLevel(int level) {
        this.level = level;
        this.notifyObservers();
    }

    public void notifyObservers() {

        for(Observer observer ：observers ) {
            if(level >=0) {

                if("A".euqals(observer.getState())) {
                        observer.update(this);
                }
            }

            if(level >=1) {
                if("B".equals(observer.getState())) {
                    observer.update(this);
                }
            }
        }
    }
}
```
定义观察者接口
```java
public interface Observer {
    void update(Subject subject);
    void setState(String state);
    String getState();
}
```
定义具体观察者
```java
public ConcreteObserver implements Observer {
    private String state;

    public void setState(String state) {
        this.state = state;
    }
    public String getState() {
        return this.state;
    }

    public void update(Subject subject) {
        System.out.println( state + subject.getLevel());
    }
}
```
客户端调用
```java
public class Client {
    public state void main(String[] args) {
        ConcreteOberver observerA = new ConcreteOberver();
        observerA.setState("A");

        ConcreteObserver observerB = new ConcreteObserver();
        observerB.setState("B");

        ConcreteSubject subject = new ConcreteSubject();
        subject.register(observerA);
        subject.register(observerB);
        //通过设置不同的leve，可以通知到不同的观察者
        subject.setLevel(1);
    }
}
```
### 模式讲解
- 观察者模式(Observer)是指定义对象之间的一种一对多的依赖关系。当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被并自动更新
- 被观察者和观察者之间是典型的一对多的关系。观察者模式的本质是触发联动。
- 一个观察者可以注册多个被观察者，一个被观察者也可以观察多个观察者
- 观察者模式中是单向依赖，只有观察者依赖被观察者，而被观察者不会依赖于观察者，观察者是被动的，被观察者是主动的
- 相互观察时，容易出现死循环
- 观察者模式分为拉模型和推模型
    - 拉模型
        - 被观察者在通知观察观察者时，只传递少量信息，一般是将被观察者对象传过去，当需要具体信息时从被观察者对象中获取。拉模型假定被观察者不知道观察者需要的数据，所有直接将自身对象传传过去
    - 推模型
        - 被观察者对象主动向观察者推送详细信息。推模型假定被观察者知道观察者需要的数据，让观察者按需获取，所有观察者不能被复用。
- Java中的观察者模式
    - 被观察者需要继承java.util.Observerable
    - 观察者需要实现java.util.Observer
- 观察者模式的优点
    - 观察者和被观察者直接是抽象耦合
    - 实现了动态联动
    - 支持广播通信
- 观察者模式的缺点
    - 可以引起无谓操作
- 当需要根据不同的条件通知不同的观察者时，可以使用扩展的观察者模式
- 相关模式
    - 观察者模式和状态模式
        - 观察者模式是当被观察者状态发生改变时，通知观察者，让观察者去执行相应的操作，观察者本身还有很多其他的功能，接收通知进行相应操作知识一部分功能
        - 状态模式是根据不同的状态，选择不同的实现，实现类的功能是针对不同的状态进行相应的操作
    - 观察者模式和终结者模式
        - 观察者模式和中介者模式可以结合使用
