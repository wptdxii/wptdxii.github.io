<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="1.RxJava简介RxJava项目地址：RxJavaRxAndroid项目地址：RxAndroid RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可">
<meta property="og:type" content="article">
<meta property="og:title" content="RxJava2">
<meta property="og:url" content="http://yoursite.com/2016/08/21/RxJava2/index.html">
<meta property="og:site_name" content="wptdxii`s blog">
<meta property="og:description" content="1.RxJava简介RxJava项目地址：RxJavaRxAndroid项目地址：RxAndroid RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-10-09T09:35:24.589Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RxJava2">
<meta name="twitter:description" content="1.RxJava简介RxJava项目地址：RxJavaRxAndroid项目地址：RxAndroid RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/08/21/RxJava2/"/>





  <title>RxJava2 | wptdxii`s blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">wptdxii`s blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">hello world</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/21/RxJava2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wptdxii">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://otg3f8t90.bkt.clouddn.com/2017/7/21/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wptdxii`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">RxJava2</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-21T23:40:36+08:00">
                2016-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1-RxJava简介"><a href="#1-RxJava简介" class="headerlink" title="1.RxJava简介"></a>1.RxJava简介</h2><p>RxJava项目地址：<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a><br>RxAndroid项目地址：<a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="noopener">RxAndroid</a></p>
<p>RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库），RxJava的本质是异步。RxJava 的优势是简洁，但它的简洁的与众不同之处在于，随着程序逻辑变得越来越复杂，依然能够保持简洁，可以将复杂逻辑都能穿成一条线。</p>
<h2 id="2-RxJava原理"><a href="#2-RxJava原理" class="headerlink" title="2.RxJava原理"></a>2.RxJava原理</h2><h3 id="1-Rx的观察者模式"><a href="#1-Rx的观察者模式" class="headerlink" title="1.Rx的观察者模式"></a>1.Rx的观察者模式</h3><p>RxJava 的异步实现，是通过一种扩展的观察者模式来实现的。</p>
<p>RxJava有四个基本的概念：</p>
<ul>
<li>Observable – 被观察者</li>
<li>Observer – 观察者</li>
<li>subcribe – 订阅</li>
<li>event – 事件</li>
</ul>
<p>Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。</p>
<p>与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 onNext() 之外，还定义了两个特殊的事件：</p>
<ul>
<li>onCompleted()<br>  事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 onNext() 发出时，需要触发 onCompleted() 方法作为标志</li>
<li>onError()<br>事件队列异常。在事件处理过程中出异常时，onError() 会被触发，同时队列自动终止，不允许再有事件发出。</li>
</ul>
<p>在一个正确运行的事件序列中, onCompleted() 和 onError() 有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted() 和 onError() 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个</p>
<h2 id="3-基本实现"><a href="#3-基本实现" class="headerlink" title="3.基本实现"></a>3.基本实现</h2><h3 id="1-创建Observer"><a href="#1-创建Observer" class="headerlink" title="1.创建Observer"></a>1.创建Observer</h3><p>实现Observer接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> viod <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Item:"</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RxJava 还内置了一个实现了 Observer 的抽象类：Subscriber。 Subscriber 对 Observer 接口进行了一些扩展，但基本使用方式是完全一样的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Item:"</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不仅基本使用方式一样，实质上，在 RxJava 的 subscribe 过程中，Observer 也总是会先被转换成一个 Subscriber 再使用。所以如果你只想使用基本功能，选择 Observer 和 Subscriber 是完全一样的。两者之间的区别主要是Subscriber增加了两个方法：</p>
<ul>
<li>onStart()<br>该方法会在 subscribe刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe()</li>
<li>unsubscribe()<br>该方法是Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed() 先判断一下状态。 unsubscribe() 这个方法很重要，因为在 subscribe() 之后， Observable(被观察者) 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（如 onPause() onStop() 等方法中）调用 unsubscribe()来解除引用关系，以避免内存泄露的发生<h3 id="2-创建Observerable"><a href="#2-创建Observerable" class="headerlink" title="2.创建Observerable"></a>2.创建Observerable</h3>Observable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。 RxJava 使用 create() 方法来创建一个 Observable ，并为它定义事件触发规则：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observerable observerable = <span class="keyword">new</span> Observerable.create(<span class="keyword">new</span> Observerable.OnSubscribe() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当订阅时，下面一系列方法会被调用</span></span><br><span class="line">        subscriber.onNext(<span class="string">"Hello"</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">"World"</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">"RxJava"</span>);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>onCreate()方法传入了一个 OnSubscribe 对象作为参数。OnSubscribe 会被存储在返回的 Observable 对象中，它的作用相当于一个计划表，当 Observable 被订阅的时候，OnSubscribe 的 call() 方法会自动被调用，事件序列就会依照设定依次触发（对于上面的代码，就是观察者Subscriber 将会被调用三次 onNext() 和一次 onCompleted()）。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。</p>
<p>create() 方法是 RxJava 最基本的创造事件序列的方法。基于这个方法， RxJava 还提供了一些方法用来快捷创建事件队列：</p>
<ul>
<li><p>just(T…)<br>将传入的参数依次发送出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observerable observerable = <span class="keyword">new</span> Observerable.just(<span class="string">"Hello"</span>, <span class="string">"World"</span>, <span class="string">"RxJava"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会依次调用：</span></span><br><span class="line"><span class="comment">// onNext("Hello");</span></span><br><span class="line"><span class="comment">// onNext("World");</span></span><br><span class="line"><span class="comment">// onNext("RxJava");</span></span><br><span class="line"><span class="comment">// onCompleted();</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>from(T[])/from(Iterable&lt;? extends T&gt;)<br>将传入的数组或 Iterable 拆分成具体对象后，依次发送出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] event = <span class="keyword">new</span> String[]&#123;<span class="string">"Hello"</span>， <span class="string">"World"</span>, <span class="string">"RxJava"</span>&#125;;</span><br><span class="line">Observerable observerable = <span class="keyword">new</span> Observerable.from(event);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会依次调用：</span></span><br><span class="line"><span class="comment">// onNext("Hello");</span></span><br><span class="line"><span class="comment">// onNext("World");</span></span><br><span class="line"><span class="comment">// onNext("RxJava");</span></span><br><span class="line"><span class="comment">// onCompleted();</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-Subscribe-订阅"><a href="#3-Subscribe-订阅" class="headerlink" title="3.Subscribe(订阅)"></a>3.Subscribe(订阅)</h3><p>创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来，整条链子就可以工作了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observerable.subscribe(Observer);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">Observerable.subscribe(Subscriber);</span><br></pre></td></tr></table></figure></p>
<p>Observable.subscribe(Subscriber) 的内部实现是这样的（仅核心代码）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这不是 subscribe() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber subscriber)</span> </span>&#123;</span><br><span class="line">    subscriber.onStart();</span><br><span class="line">    onSubscribe.call(subscriber);</span><br><span class="line">    <span class="keyword">return</span> subscriber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>subscribe() 做了3件事：</p>
<ul>
<li>调用 Subscriber.onStart()<br>onStart()是一个可选的准备方法,该方法会在 subscribe刚开始，而事件还未发送之前被调用，可以用于做一些准备工作</li>
<li>调用 Observable 中的 OnSubscribe.call(Subscriber)<br>在这里，事件发送的逻辑开始运行。从这也可以看出，在 RxJava 中， Observable 并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 subscribe() 方法执行的时候。</li>
<li>将传入的 Subscriber 作为 Subscription 返回。这是为了方便 unsubscribe()</li>
</ul>
<p>除了 subscribe(Observer) 和 subscribe(Subscriber) ，subscribe() 还支持不完整定义的回调，RxJava 会自动根据定义创建出 Subscriber 。形式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Action1&lt;String&gt; onNextAction = <span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">    <span class="comment">//onNext()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Action1&lt;Throwable&gt; onErrorAction = <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</span><br><span class="line">    <span class="comment">//onError()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Error Handling</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Action0 onCompletedAction = <span class="keyword">new</span> Action0&lt;&gt;() &#123;</span><br><span class="line">    <span class="comment">//onCompleted()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()</span></span><br><span class="line">observable.subscribe(onNextAction);</span><br><span class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()</span></span><br><span class="line">observable.subscribe(onNextAction, onErrorAction);</span><br><span class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()</span></span><br><span class="line">observable.subscribe(onNextAction, onErrorAction, onCompletedAction);</span><br></pre></td></tr></table></figure></p>
<p>Action0 是 RxJava 的一个接口，它只有一个方法 call()，这个方法是无参无返回值的；由于 onCompleted() 方法也是无参无返回值的，因此 Action0 可以被当成一个包装对象，将 onCompleted() 的内容打包起来将自己作为一个参数传入 subscribe() 以实现不完整定义的回调。这样其实也可以看做将 onCompleted() 方法作为参数传进了 subscribe()，相当于其他某些语言中的『闭包』。 Action1 也是一个接口，它同样只有一个方法 call(T param)，这个方法也无返回值，但有一个参数；与 Action0 同理，由于 onNext(T obj) 和 onError(Throwable error) 也是单参数无返回值的，因此 Action1 可以将 onNext(obj) 和 onError(error) 打包起来传入 subscribe() 以实现不完整定义的回调。事实上，虽然 Action0 和 Action1 在 API 中使用最广泛，但 RxJava 是提供了多个 ActionX 形式的接口 (例如 Action2, Action3) 的，它们可以被用以包装不同的无返回值的方法。</p>
<h3 id="4-场景示例"><a href="#4-场景示例" class="headerlink" title="4.场景示例"></a>4.场景示例</h3><p><strong>打印字符串数据</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] names = ...;</span><br><span class="line">Observerable.from(names)</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Action1&lt;string&gt;()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                    Log.d(tag, s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>由id取得图片并显示</strong><br>由指定的一个 drawable 文件 id drawableRes 取得图片，并显示在 ImageView 中，并在出现异常的时候打印 Toast 报错：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> drawableRes = ...;</span><br><span class="line">ImageView ImageView = ...;</span><br><span class="line">Observerable.create(<span class="keyword">new</span> Observerable.OnSubscribe&lt;Drawable&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Drawable&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        Drawable drawable = getTheme().getDrawable(drawableRes);</span><br><span class="line">        subscriber.onNext(drawable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> SubScriber&lt;Drawable&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Drawable drawable)</span> </span>&#123;</span><br><span class="line">        ImageView.setImageDrawable(drawable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Toast.makeText().(context, <span class="string">"Error"</span>,Toast.LENGTH_SHOR).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在 RxJava 的默认规则中，事件的发出和消费都是在同一个线程的。也就是说，如果只用上面的方法，实现出来的只是一个同步的观察者模式。观察者模式本身的目的就是『后台处理，前台回调』的异步机制，因此异步对于 RxJava 是至关重要的。而要实现异步，则需要用到 RxJava 的另一个概念： Scheduler 。</p>
<h2 id="3-变换"><a href="#3-变换" class="headerlink" title="3.变换"></a>3.变换</h2><h3 id="1-map"><a href="#1-map" class="headerlink" title="1.map()"></a>1.map()</h3><p>首先看map()使用的实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">filePath = <span class="string">"image/logo/png"</span></span><br><span class="line"><span class="comment">// 输入类型 String</span></span><br><span class="line">Observerable.just(filePaht)</span><br><span class="line">            .map(<span class="keyword">new</span> Func1&lt;String Bitmap&gt;()&#123;<span class="comment">// 参数类型 String</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Bitmap <span class="title">call</span><span class="params">(String filePath)</span></span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> getBitmapFromFile(filePath); <span class="comment">// 返回类型 Bitmap</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .subsciebe(<span class="keyword">new</span> Action1&lt;Bitmap&gt;()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Bitmap Bitmap)</span></span>&#123;<span class="comment">// 参数类型 Bitmap</span></span><br><span class="line">                    showBitmap(bitmap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure></p>
<p>Func 类和 Action 类非常相似，也是 RxJava 的一个接口，用于包装含有一个参数的方法。 Func1 和 Action 的区别在于， Func1 包装的是有返回值的方法。另外，和 ActionX 一样， FuncX 也有多个，用于不同参数个数的方法。FuncX 和 ActionX 的区别在 FuncX 包装的是有返回值的方法。</p>
<p>map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。RxJava 不仅可以针对事件对象，还可以针对整个事件队列变换，这使得 RxJava 变得非常灵活</p>
<h3 id="2-flatMap"><a href="#2-flatMap" class="headerlink" title="2.flatMap()"></a>2.flatMap()</h3><p>首先用示例来说明，假设有一个数据结构『学生』，现在需要打印出一组学生的名字：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = ...;</span><br><span class="line">Observerable.from(students)</span><br><span class="line">    .map(<span class="keyword">new</span> Func1&lt;Student,String&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> student.getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscibe(<span class="keyword">new</span> Action1&lt;String&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            Log.d(tag, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>接着打印出每个学生所需要修的所有课程，首先可以这样实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = ...;</span><br><span class="line">Observerable.create(<span class="keyword">new</span> Observerable.OnSubscribe()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscirber&lt;? extend Student&gt; subscirber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Student student : students) &#123;</span><br><span class="line">            subscriber.onNext(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.subscibe(<span class="keyword">new</span> Subscirber&lt;Student&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        List&lt;Course&gt; couses = student.getCources();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; course.size(); i++) &#123;</span><br><span class="line">            Cource cource = couses.get(i);</span><br><span class="line">            Log.d(tag, cource.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>可是如果不想在 Subscriber 中使用 for 循环，而是希望 Subscriber 中直接传入单个的 Course 对象（这对于代码复用很重要），用 map() 显然是不行的，因为 map() 是一对一的转化，而现在的要求是一对多的转化。这时可以使用flatMap()来实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = ...;</span><br><span class="line">Observerable.from(students)</span><br><span class="line">        .flatMap(<span class="keyword">new</span> Func1&lt;Student,Observerable&lt;Cource&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Observerable&lt;Cource&gt; <span class="title">call</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Observerable.from(student.getCources());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Cource&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Cource cource)</span> </span>&#123;</span><br><span class="line">                Log.d(tag, cource.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></p>
<p>由实例可以看出，flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 map() 不同的是， flatMap() 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。<br>flatMap() 的原理是这样的：</p>
<ol>
<li>使用传入的事件对象创建一个 Observable 对象；</li>
<li>并不发送这个 Observable, 而是将它激活，于是它开始发送事件；</li>
<li>每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。</li>
</ol>
<p>这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 flatMap() 所谓的 flat。</p>
<p>由于可以在嵌套的 Observable 中添加异步代码， flatMap() 也常用于嵌套的异步操作，例如嵌套的网络请求。示例代码（Retrofit + RxJava）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ApiFactory.getToken()<span class="comment">// 返回 Observable&lt;String&gt;，在订阅时请求 token，并在响应后发送 token</span></span><br><span class="line">    .flaMap(<span class="keyword">new</span> Func1&lt;String, Observerable&lt;Messages&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observerable&lt;Messages&gt; <span class="title">call</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ApiFactory.getMessages(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Messages&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Messages messages)</span></span>&#123;</span><br><span class="line">            showMessages(messages);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>RxJava 提供了对事件序列进行变换的支持，所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。</p>
<h3 id="3-throttleFirst"><a href="#3-throttleFirst" class="headerlink" title="3.throttleFirst()"></a>3.throttleFirst()</h3><p>在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤</p>
<h3 id="4-变换的原理"><a href="#4-变换的原理" class="headerlink" title="4.变换的原理"></a>4.变换的原理</h3><h4 id="1-lift"><a href="#1-lift" class="headerlink" title="1.lift()"></a>1.lift()</h4><p>变换虽然功能各有不同，但实质上都是针对事件序列的处理和再发送。而在 RxJava 的内部，它们是基于同一个基础的变换方法： lift(Operator)。首先看一下 lift() 的内部实现（仅核心代码）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这不是 lift() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">lift</span><span class="params">(Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> OnSubscribe&lt;R&gt;() &#123; </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber subscriber)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//observeOn()在这里控制线程  在operator 的call()方法内向下一级Subscriber发送通知</span></span><br><span class="line">            Subscriber newSubscriber = operator.call(subscriber);</span><br><span class="line">            newSubscriber.onStart();</span><br><span class="line">            <span class="comment">//这个onSubscribe对象指的是最外部Observable对象持有的OnSubscribed对象</span></span><br><span class="line">            <span class="comment">//subscribeOn（）控制了这里的线程切换，onSubscribe指的是上一层Observable对象持有的onSubscribe对象</span></span><br><span class="line">            onSubscribe.call(newSubscriber);<span class="comment">//注意这个语句</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>lift()方法生成了一个新的 Observable 并返回，而且创建新 Observable 所用的参数 OnSubscribe 的回调方法 call() 中的实现与之前的Observable.subscribe()方法的实现很相似，再看一下Observable.subscribe()方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这不是 subscribe() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber subscriber)</span> </span>&#123;</span><br><span class="line">    subscriber.onStart();</span><br><span class="line">    onSubscribe.call(subscriber);<span class="comment">//两个方法都有该句</span></span><br><span class="line">    <span class="keyword">return</span> subscriber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个方法内部都有该语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onSubscribe.call(subscriber)</span><br></pre></td></tr></table></figure></p>
<p>onSubscribe 是 Observable 内部持有一个对象，当 Observable 调用 create()方法进行对象创建时被初始化。在上面那相同条语句中，onSubscribe所代指的对象是不相同的：</p>
<ul>
<li>subscribe() 方法中的 onSubscribe 指的是 Observable 中的 onSubscribe 对象</li>
<li>当含有 lift() 时：<ul>
<li>lift()方法创建了一个新的Observable 对象并返回，在lift()方法被原始的Observable 对象调用之后，加上之前的原始 Observable，已经有两个 Observable 对象</li>
<li>而同样地，新 Observable 里的新 OnSubscribe 加上之前的原始 Observable 中的原始 OnSubscribe，也就有了两个 OnSubscribe</li>
<li>链式调用 Observable.lift().suscribe(Subscriber)的过程是，当调用经过 lift() 后的 Observable 的 subscribe() 的时候，使用的是 lift() 所返回的新的 Observable ，于是它所触发的 onSubscribe.call(subscriber)，也是用的新 Observable 中的新 OnSubscribe，即在 lift() 中生成的那个 OnSubscribe</li>
<li>而这个新 OnSubscribe 的 call() 方法中的 onSubscribe ，就是指的原始 Observable 中的原始 OnSubscribe ，在这个 call() 方法里，新 OnSubscribe 利用 operator.call(subscriber) 生成了一个新的 Subscriber（Operator 就是在这里，通过自己的 call() 方法将新 Subscriber 和原始 Subscriber 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新 Subscriber 向原始 Observable 进行订阅，即原始的 OnSubscribe 的 call() 方法被调用</li>
</ul>
</li>
</ul>
<p>这样就实现了 lift() 的过程，有点像一种代理机制，通过事件拦截和处理实现事件序列的变换。精简掉细节的话，也可以这么说： 在 Observable 执行了 lift(Operator) 方法之后，会返回一个新的 Observable，这个新的 Observable 会像一个代理一样，负责接收原始的 Observable 发出的事件，并在处理后发送给 Subscriber。<br>为了便于理解，举一个具体的 Operator 的实现。下面这是一个将事件中的 Integer 对象转换成 String 的例子，仅供参考：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的泛型Operator&lt;R,T&gt;正好与泛型map(T,R)相反</span></span><br><span class="line">observable.lift(<span class="keyword">new</span> Observable.Operator&lt;String, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SubScriber&lt;? <span class="keyword">super</span> Integer&gt; call(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Subscriber&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                subscriber.onNext(integer+<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                subscriber.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                subscriber.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>RxJava 都不建议开发者自定义 Operator 来直接使用 lift()，而是建议尽量使用已有的 lift() 包装方法（如 map() flatMap() 等）进行组合来实现需求，因为直接使用 lift() 非常容易发生一些难以发现的错误</p>
<h4 id="2-compose"><a href="#2-compose" class="headerlink" title="2.compose()"></a>2.compose()</h4><p>除了 lift() 之外， Observable 还有一个变换方法叫做 compose(Transformer)。它和 lift() 的区别在于， lift() 是针对事件项和事件序列的，而 compose() 是针对 Observable 自身进行变换。举个例子，假设在程序中有多个 Observable ，并且他们都需要应用一组相同的 lift() 变换。可以这么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">observable1</span><br><span class="line">    .lift1()</span><br><span class="line">    .lift2()</span><br><span class="line">    .lift3()</span><br><span class="line">    .lift4()</span><br><span class="line">    .subscribe(subscriber1);</span><br><span class="line">observable2</span><br><span class="line">    .lift1()</span><br><span class="line">    .lift2()</span><br><span class="line">    .lift3()</span><br><span class="line">    .lift4()</span><br><span class="line">    .subscribe(subscriber2);</span><br></pre></td></tr></table></figure></p>
<p>冗余代码太多，可以改为这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Observable <span class="title">liftAll</span><span class="params">(Observable observable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> observable</span><br><span class="line">        .lift1()</span><br><span class="line">        .lift2()</span><br><span class="line">        .lift3()</span><br><span class="line">        .lift4();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">liftAll(observable1).subscribe(subscriber1);</span><br><span class="line">liftAll(observable2).subscribe(subscriber2);</span><br></pre></td></tr></table></figure></p>
<p>这种方式对于 Observale 的灵活性增添了限制，破坏了流式的风格，这个时候，可以用 compose() 来解决：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftAllTransformer</span> <span class="keyword">implements</span> <span class="title">Observable</span>.<span class="title">Transformer</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(Observable&lt;Integer&gt; observable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> observable</span><br><span class="line">            .lift1()</span><br><span class="line">            .lift2()</span><br><span class="line">            .lift3()</span><br><span class="line">            .lift4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Transformer liftAll = <span class="keyword">new</span> LiftAllTransformer();</span><br><span class="line">observable1.compose(liftAll).subscribe(subscriber1);</span><br><span class="line">observable2.compose(liftAll).subscribe(subscriber2);</span><br></pre></td></tr></table></figure></p>
<h2 id="4-线程控制"><a href="#4-线程控制" class="headerlink" title="4.线程控制"></a>4.线程控制</h2><p>在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。</p>
<h3 id="1-Scheduler使用"><a href="#1-Scheduler使用" class="headerlink" title="1.Scheduler使用"></a>1.Scheduler使用</h3><p>在RxJava 中Scheduler(调度器)，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 Scheduler ，它们已经适合大多数的使用场景：</p>
<ul>
<li>Schedulers.immediate()<br>直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler</li>
<li>Schedulers.trampoline()<br>在当前线程执行，与immediate不同的是，它并不会立即执行，而是将其存入队列，等待当前Scheduler中其它任务执行完毕后执行，这个在我们时常使用的并不多，它主要服务于repeat ，retry这类特殊的变换操作。</li>
<li>Schedulers.newThread()<br>总是启用新线程，并在新线程执行操作</li>
<li>Schedulers.io()<br>I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程</li>
<li>Schedulers.computation()<br>计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU</li>
<li>AndroidSchedulers.mainThread()<br>Android中专用的Scheduler，指定的操作将在 Android 主线程运行，由RxAndroid提供</li>
</ul>
<p>有了Scheduler，使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制：</p>
<ul>
<li>subscribeOn()<br>指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程</li>
<li>observeOn()<br>指定 Subscriber 所运行在的线程。或者叫做事件消费的线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Oberverable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    .subscribeOn(Schedulers.io())<span class="comment">// 指定 subscribe() 发生在 IO 线程</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())<span class="comment">// 指定 Subscriber 的回调发生在主线程</span></span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer number)</span> </span>&#123;</span><br><span class="line">            Log.d(tag, number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>改写由id取得图片并显示的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> drawableRes = ...;</span><br><span class="line">ImageView ImageView = ...;</span><br><span class="line">Observerable.create(<span class="keyword">new</span> Observerable.OnSubscribe&lt;Drawable&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Drawable&gt; subscriber)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//加载图片将会发生在 IO 线程</span></span><br><span class="line">        Drawable drawable = getTheme().getDrawable(drawableRes);</span><br><span class="line">        subscriber.onNext(drawable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">.subscribeOn(Schedulers.io())</span><br><span class="line">.observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">.subscribe(<span class="keyword">new</span> SubScriber&lt;Drawable&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Drawable drawable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置图片则被设定在了主线程</span></span><br><span class="line">        ImageView.setImageDrawable(drawable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Toast.makeText().(context, <span class="string">"Error"</span>,Toast.LENGTH_SHOR).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Oberverable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer number)</span> </span>&#123;</span><br><span class="line">            Log.d(tag, number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>observeOn() 指定的是 Subscriber 的线程，而这个 Subscriber 并不是（严格说应该为『不一定是』，但这里不妨理解为『不是』）subscribe() 参数中的 Subscriber ，而是 observeOn() 执行时的当前 Observable 所对应的 Subscriber ，即它的直接下级 Subscriber 。换句话说，observeOn() 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 observeOn() 即可。示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observerable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)<span class="comment">// IO 线程，由 subscribeOn() 指定</span></span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(Schedulers.newThread())</span><br><span class="line">    .map(mapOperator)<span class="comment">//// 新线程，由 observeOn() 指定</span></span><br><span class="line">    .observerOn(Schedulers.io())</span><br><span class="line">    .map(mapOperator2)<span class="comment">// IO 线程，由 observeOn() 指定</span></span><br><span class="line">    .oberveOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(SubScriber);<span class="comment">// Android 主线程，由 observeOn() 指定</span></span><br></pre></td></tr></table></figure></p>
<p>通过 observeOn() 的多次调用，程序实现了线程的多次切换。不同于 observeOn() ， subscribeOn() 的位置放在哪里都可以，但它是只能调用一次的。当使用了多个 subscribeOn() 的时候，只有第一个 subscribeOn() 起作用。</p>
<h3 id="2-doOnSubscribe"><a href="#2-doOnSubscribe" class="headerlink" title="2.doOnSubscribe()"></a>2.doOnSubscribe()</h3><p>虽然超过一个的 subscribeOn() 对事件处理的流程没有影响，但在流程之前却是可以利用的。Subscriber 的 onStart() 可以用作流程开始前的初始化。然而 onStart() 由于在 subscribe() 发生时就被调用了，因此不能指定线程，而是只能执行在 subscribe() 被调用时的线程。这就导致如果 onStart() 中含有对线程有要求的代码（例如在界面上显示一个 ProgressBar，这必须在主线程执行），将会有线程非法的风险，因为有时你无法预测 subscribe() 将会在什么线程执行。</p>
<p>与 Subscriber.onStart() 相对应的，有一个方法 Observable.doOnSubscribe() 。它和 Subscriber.onStart() 同样是在 subscribe() 调用后而且在事件发送前执行，但区别在于它可以指定线程。默认情况下， doOnSubscribe() 执行在 subscribe() 发生的线程；而如果在 doOnSubscribe() 之后有 subscribeOn() 的话，它将执行在离它最近的 subscribeOn() 所指定的线程。</p>
<p>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observerable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)<span class="comment">//IO 线程，由 subscribeOn() 指定</span></span><br><span class="line">            .subscribeOn(Shcedulers.io())</span><br><span class="line">            .doOnSubscribe(<span class="keyword">new</span> Action0()&#123;Android 主线程，由后边最近的 subscribeOn() 指定</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    progressBar.setVisibility(View.Visible);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .subscribeOn(AndroidSchedulers.mainThread())<span class="comment">//指定doOnSubscribe()线程</span></span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(Subscriber);<span class="comment">// Android 主线程，由 observeOn() 指定</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-Scheduler原理"><a href="#3-Scheduler原理" class="headerlink" title="3.Scheduler原理"></a>3.Scheduler原理</h3><p>subscribeOn() 和 observeOn() 都做了线程切换的工作。<br>subscribeOn() 和 observeOn() 的内部实现，也是用的 lift()。subscribeOn() 和 observeOn() 方法都会创建一个新的 Observable 对象，不同的是， subscribeOn() 的线程切换发生在 新的Observable 对象的 OnSubscribe 中即在它通知上一级 OnSubscribe 时，这时事件还没有开始发送，因此 subscribeOn() 的线程控制可以从事件发出的开端就造成影响；而 observeOn() 的线程切换则发生在它内建的 Subscriber 中，即发生在它即将给下一级 Subscriber 发送事件时，因此 observeOn() 控制的是它后面的线程。</p>
<h4 id="1-subscribOn"><a href="#1-subscribOn" class="headerlink" title="1.subscribOn()"></a>1.subscribOn()</h4><h4 id="2-observOn"><a href="#2-observOn" class="headerlink" title="2.observOn()"></a>2.observOn()</h4><h4 id="3-线程切换规律"><a href="#3-线程切换规律" class="headerlink" title="3.线程切换规律"></a>3.线程切换规律</h4><p>线程切换时有如下规律：</p>
<ul>
<li>当使用了多个 subscribeOn() 的时候，只有第一个 subscribeOn() 起作用，这个 subscribeOn() 控制从流程开始的第一个操作，直到遇到第一个 observeOn()</li>
<li>可以通过 observeOn() 的多次调用，实现线程的多次切换。每个 observeOn() 将导致一次线程切换()，这次切换开始于这次 observeOn() 的下一个操作</li>
<li>不论是 subscribeOn() 还是 observeOn()，每次线程切换如果不受到下一个 observeOn() 的干预，线程将不再改变，不会自动切换到其他线程</li>
</ul>
<h2 id="5-RxJava使用场景"><a href="#5-RxJava使用场景" class="headerlink" title="5.RxJava使用场景"></a>5.RxJava使用场景</h2><h3 id="1-与Retrofit结合"><a href="#1-与Retrofit结合" class="headerlink" title="1.与Retrofit结合"></a>1.与Retrofit结合</h3><p>Retrofit 除了提供了传统的 Callback 形式的 API，还有 RxJava 版本的 Observable 形式 API。下面用对比的方式来介绍 Retrofit 的 RxJava 版 API 和传统版本的区别。<br>以获取一个 User 对象的接口作为例子。使用Retrofit 的传统 API，可以这样实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"user"</span>)</span><br><span class="line">    <span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">(@Query(<span class="string">"userId"</span>)</span> String userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用Retrofit实现请求<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Call&lt;User&gt;&gt; call  = ApiFactory.getUser();</span><br><span class="line">call.enquue(<span class="keyword">new</span> Callback&lt;User&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;User&gt; call, Response&lt;User&gt; response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        userView.setUser(response.body());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;User&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Error Handling</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>而使用 RxJava 形式的 API，定义同样的请求是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interafce Api &#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"user"</span>)</span><br><span class="line">    <span class="function">Observerable&lt;User&gt; <span class="title">getUser</span><span class="params">(@Query(<span class="string">"userId"</span>)</span> String userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用Retrofit实现请求<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ApiFactory.getUser(userId)<span class="comment">//返回Observable&lt;User&gt;</span></span><br><span class="line">          .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">          .subscribe(<span class="keyword">new</span> Subscriber&lt;User&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">                userView.setUser(user);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Completed Handling</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Error Handling</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br></pre></td></tr></table></figure></p>
<p>对比来看， Callback 形式和 Observable 形式长得不太一样，但本质都差不多，而且在细节上 Observable 形式似乎还比 Callback 形式要差点。但当情况变得复杂一些，假设这么一种情况：取到的 User 并不应该直接显示，而是需要先与数据库中的数据进行比对和修正后再显示。使用 Callback 方式大概可以这么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Call&lt;User&gt;&gt; call  = ApiFactory.getUser(userId);</span><br><span class="line">call.enquue(<span class="keyword">new</span> Callback&lt;User&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;User&gt; call, Response&lt;User&gt; response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function">pub <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                processUser(user);<span class="comment">//在分线程修正数据</span></span><br><span class="line">                runOnUiThread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        userView.setUser(user);<span class="comment">//在主线程更新界面</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;User&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Error Handling</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这时的代码可读性太差，如果使用RxJava 形式的代码来实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ApiFactory.getUser(userId)</span><br><span class="line">          .doOnNext(<span class="keyword">new</span> Action1&lt;User&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(User User)</span></span>&#123;</span><br><span class="line">                processUser(User);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          .subscribeOn(Schedulers.io())</span><br><span class="line">          .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">          .subscribe(<span class="keyword">new</span> SUscriber&lt;User&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">                userView.setUser(user);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Completed Handling</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Error Handling</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-RxBinding"><a href="#2-RxBinding" class="headerlink" title="2.RxBinding"></a>2.RxBinding</h3><p>RxBing项目地址: <a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="noopener">RxBinding</a></p>
<p>RxBinding 提供了一套在 Android 平台上的基于 RxJava 的 Binding API。所谓 Binding，就是类似设置 OnClickListener 、设置 TextWatcher 这样的注册绑定对象的 API。</p>
<h3 id="3-异步操作"><a href="#3-异步操作" class="headerlink" title="3.异步操作"></a>3.异步操作</h3><h3 id="4-RxBus"><a href="#4-RxBus" class="headerlink" title="4.RxBus"></a>4.RxBus</h3>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/20/Android逆向总结/" rel="next" title="Android逆向总结">
                <i class="fa fa-chevron-left"></i> Android逆向总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/08/22/Android事件分发机制/" rel="prev" title="Android事件分发机制">
                Android事件分发机制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://otg3f8t90.bkt.clouddn.com/2017/7/21/avatar.jpg"
               alt="wptdxii" />
          <p class="site-author-name" itemprop="name">wptdxii</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">72</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">46</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wptdxii" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/p/1005055245629016/home" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-RxJava简介"><span class="nav-number">1.</span> <span class="nav-text">1.RxJava简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-RxJava原理"><span class="nav-number">2.</span> <span class="nav-text">2.RxJava原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Rx的观察者模式"><span class="nav-number">2.1.</span> <span class="nav-text">1.Rx的观察者模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-基本实现"><span class="nav-number">3.</span> <span class="nav-text">3.基本实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-创建Observer"><span class="nav-number">3.1.</span> <span class="nav-text">1.创建Observer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-创建Observerable"><span class="nav-number">3.2.</span> <span class="nav-text">2.创建Observerable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Subscribe-订阅"><span class="nav-number">3.3.</span> <span class="nav-text">3.Subscribe(订阅)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-场景示例"><span class="nav-number">3.4.</span> <span class="nav-text">4.场景示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-变换"><span class="nav-number">4.</span> <span class="nav-text">3.变换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-map"><span class="nav-number">4.1.</span> <span class="nav-text">1.map()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-flatMap"><span class="nav-number">4.2.</span> <span class="nav-text">2.flatMap()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-throttleFirst"><span class="nav-number">4.3.</span> <span class="nav-text">3.throttleFirst()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-变换的原理"><span class="nav-number">4.4.</span> <span class="nav-text">4.变换的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-lift"><span class="nav-number">4.4.1.</span> <span class="nav-text">1.lift()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-compose"><span class="nav-number">4.4.2.</span> <span class="nav-text">2.compose()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-线程控制"><span class="nav-number">5.</span> <span class="nav-text">4.线程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Scheduler使用"><span class="nav-number">5.1.</span> <span class="nav-text">1.Scheduler使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-doOnSubscribe"><span class="nav-number">5.2.</span> <span class="nav-text">2.doOnSubscribe()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Scheduler原理"><span class="nav-number">5.3.</span> <span class="nav-text">3.Scheduler原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-subscribOn"><span class="nav-number">5.3.1.</span> <span class="nav-text">1.subscribOn()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-observOn"><span class="nav-number">5.3.2.</span> <span class="nav-text">2.observOn()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-线程切换规律"><span class="nav-number">5.3.3.</span> <span class="nav-text">3.线程切换规律</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-RxJava使用场景"><span class="nav-number">6.</span> <span class="nav-text">5.RxJava使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-与Retrofit结合"><span class="nav-number">6.1.</span> <span class="nav-text">1.与Retrofit结合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-RxBinding"><span class="nav-number">6.2.</span> <span class="nav-text">2.RxBinding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-异步操作"><span class="nav-number">6.3.</span> <span class="nav-text">3.异步操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-RxBus"><span class="nav-number">6.4.</span> <span class="nav-text">4.RxBus</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wptdxii</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
